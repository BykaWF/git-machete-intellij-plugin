#!/usr/bin/env bash

set -e -o pipefail -u

self_dir=$(cd "$(dirname "$0")" &>/dev/null; pwd -P)
source "$self_dir"/utils.sh


intellij_version=${1-} # can be skipped; the same IntelliJ version that the plugin has been built against will be assumed

ide_log=build/idea-sandbox/system/log/idea.log
# idea.log is not automatically cleared before each `runIde(forUiTests)`
# and we don't want to print the potential logs from the previous runs.
ide_log_last_line=$(cat $ide_log 2>/dev/null | wc -l || true)  # will be 0 if $ide_log doesn't exist yet

function ide_logs_from_this_run() {
  tail -n+$((ide_log_last_line+1)) $ide_log
}

# If we're on CI, run IDE on X Virtual Framebuffer; otherwise, open a regular window.
# --auto-servernum is deprecated in favor of --auto-display,
# but unfortunately xvfb-run available for Debian Buster (base of our CI image) doesn't support the latter.
command=${CI:+xvfb-run --auto-servernum}
gradle_run_ide_log=~/gradlew-runIdeForUiTests.log
$command ./gradlew -PintellijVersionForRunIde=$intellij_version --max-workers=1 -Dorg.gradle.jvmargs=-Xmx256M runIdeForUiTests >$gradle_run_ide_log 2>&1 &

# $! expands to the PID of the last process executed in the background
ide_pid=$!
function is_ide_running() {
  ps -p $ide_pid >/dev/null 2>&1
}

# Let's make sure the IDE process is terminated in case gracefully closing the IDE in @After failed for whatever reason.
function finish() {
  if is_ide_running; then
    kill -TERM $ide_pid || true  # ignoring exit code in case the process just terminated between `is_ide_running` and `kill`
  fi
  # Let's wait until IDE process is terminated to avoid any risk of race conditions
  # when another UI test is to be run right after this script completes.
  local count=0
  while is_ide_running; do
    # Rather unlikely, IDE process tends to shut down quickly on receiving SIGTERM.
    if [[ $((count++)) -eq 10 ]]; then
      kill -KILL $ide_pid || true
    fi
    echo 'Waiting for IDE process to shut down...'
    sleep 1.0
  done
}
trap finish EXIT

gradle_run_ide_log_last_line=0
# Let's wait until Remote Robot plugin living within the IDE starts listening.
info 'Logs of gradle runIdeForUiTests'
while ! nc -z localhost 8080; do
  sleep 0.5
  tail -n+$((gradle_run_ide_log_last_line+1)) $gradle_run_ide_log
  gradle_run_ide_log_last_line=$(wc -l < $gradle_run_ide_log)
  if ! is_ide_running; then
    die 'IDE failed to start, aborting'
  fi
done

info 'Logs of gradle uiTests:test'
./gradlew -PenableUiTests --info --max-workers=1 -Dorg.gradle.jvmargs=-Xmx256M uiTests:test || {
  info 'Logs of IDE under test'
  ide_logs_from_this_run
  die 'UI tests failed; inspect Gradle and IDE logs above'
}

if ide_logs_from_this_run | grep -q ' ERROR - '; then
  info 'Logs of IDE under test'
  ide_logs_from_this_run
  die 'UI tests passed, but IDE logs contain errors; inspect Gradle and IDE logs above'
fi
