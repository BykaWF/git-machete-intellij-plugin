plugins {
  id 'org.gradle.checkstyle'
  id 'org.gradle.java-library'

  id 'com.diffplug.gradle.spotless' version '3.27.2' apply false
  id 'org.checkerframework' version '0.4.14' apply false
  id 'org.jetbrains.intellij' version '0.4.18' apply false
  id 'se.bjurr.violations.violations-gradle-plugin' version '1.40' apply false
}

task resolveDependencies {
  doLast {
    project.rootProject.allprojects.each { subProject ->
      subProject.buildscript.configurations.each { configuration ->
        if (configuration.canBeResolved) {
          configuration.resolve()
        }
      }
      subProject.configurations.each { configuration ->
        if (configuration.canBeResolved) {
          configuration.resolve()
        }
      }
    }
  }
}

allprojects {
  // Keeping `repositories`, specifically `mavenCentral()` in `allprojects` rather than in `subprojects`
  // is only needed as workaround for `resolveDependencies` task.
  // Otherwise it fails when resolving dependencies for checkstyle.
  repositories {
    jcenter()
    mavenCentral()
  }
}

subprojects {
  group 'com.virtuslab'
  apply from: '../version.gradle'
  version PLUGIN_VERSION

  apply plugin: 'org.gradle.java-library'
  sourceCompatibility = 11

  gradle.projectsEvaluated {
    tasks.withType(JavaCompile) {
      // Treat each compiler warning (esp. the ones coming from Checker Framework) as an error.
      options.compilerArgs << "-Werror"
    }
  }

  apply plugin: 'org.checkerframework'
  checkerFramework {
    excludeTests = true
    checkers = [
      'org.checkerframework.checker.formatter.FormatterChecker',
      'org.checkerframework.checker.guieffect.GuiEffectChecker',
      'org.checkerframework.checker.index.IndexChecker',
      'org.checkerframework.checker.nullness.NullnessChecker',
      'org.checkerframework.checker.optional.OptionalChecker',
      'org.checkerframework.checker.regex.RegexChecker',
    ]
    extraJavacArgs = [
      '-AassumeAssertionsAreEnabled',
      '-AinvariantArrays',
      '-ArequirePrefixInWarningSuppressions',
      '-AshowSuppressWarningKeys',
      "-Astubs=$rootDir/config/checker/",
      '-AsuppressWarnings=all:type.anno.before.modifier',
    ]
  }

  apply plugin: 'com.diffplug.gradle.spotless'
  spotless {
    java {
      importOrder 'java', 'javax', '', 'com.virtuslab'
      // See https://github.com/diffplug/spotless/blob/master/ECLIPSE_SCREENSHOTS.md on importing and exporting settings from Eclipse
      eclipse().configFile "$rootDir/config/spotless/formatting-rules.xml"
      removeUnusedImports()
    }
  }

  apply plugin: 'checkstyle'
  checkstyle {
    toolVersion '8.30'

    // ignoreFailures here because we want to set conditions that will cause build fail in violations plugin
    ignoreFailures = false
    checkstyleTest.enabled = false

    // This enables "importing" subconfig files to main file (DTD ENTITY feature)
    System.setProperty('checkstyle.enableExternalDtdLoad', 'true')

    configProperties = [rootCheckstyleConfigDir: "$rootDir/config/checkstyle"]

    def checkstyleRelativeConfigPath = 'config/checkstyle/checkstyle.xml'

    def subprojectConfigFile = new File(projectDir, checkstyleRelativeConfigPath)
    // Check if module-specific config file exists. If exists then apply
    if(subprojectConfigFile.isFile()) {
      configFile = subprojectConfigFile;
    } else {
      configFile = new File(rootDir, checkstyleRelativeConfigPath)
    }
  }

  apply plugin: 'se.bjurr.violations.violations-gradle-plugin'
  task violations(type: se.bjurr.violations.gradle.plugin.ViolationsTask) {
    // Optional config
    maxReporterColumnWidth = 0 // 0 means "no limit"
    maxRuleColumnWidth = 60
    maxSeverityColumnWidth = 0
    maxLineColumnWidth = 0
    maxMessageColumnWidth = 100

    // Global configuration, remove if you don't want to report violations for the entire repo.
    minSeverity = 'WARN' // INFO, WARN or ERROR
    detailLevel = 'VERBOSE' // PER_FILE_COMPACT, COMPACT or VERBOSE
    maxViolations = 0 // Will fail the build if total number of found violations is higher
    printViolations = true // Will print violations found in diff

    // This is mandatory regardless of if you want to report violations between revisions or the entire repo.
    // Many more formats available, see: https://github.com/tomasbjerre/violations-lib
    violations = [
      ['CHECKSTYLE', buildDir.path, '.*/checkstyle/.*\\.xml\$', 'Checkstyle']
    ]
  }

  // Run violations task after each checkstyleMain run
  checkstyleMain.finalizedBy(violations)


  ext {
    intellijVersion = '2019.3'
    jgitVersion = '5.5.1.201910021850-r'
    junitVersion = '4.13'
    lombokVersion = '1.18.12'
    powerMockVersion = '2.0.6'
    slf4jVersion = '1.7.30'
    vavrVersion = '0.10.2'

    // For frontend modules other than `frontendUi`, we only use the Intellij plugin to provide dependencies,
    // but don't want the associated tasks to be available.
    disableIntellijTasks = { ->
      buildPlugin.enabled = false
      patchPluginXml.enabled = false
      prepareSandbox.enabled = false
      prepareTestingSandbox.enabled = false
      buildSearchableOptions.enabled = false
      jarSearchableOptions.enabled = false
      runIde.enabled = false
      publishPlugin.enabled = false
      verifyPlugin.enabled = false
    }

    jgit = { ->
      dependencies {
        implementation (group: 'org.eclipse.jgit', name: 'org.eclipse.jgit', version: jgitVersion) {
          // JGit transitively pulls in a version of slf4j-api (currently 1.7.2)
          // that's incompatible with the slf4j-api version that IntelliJ depends in (currently 1.7.25).
          // SLF4J guarantees that the code compiled against a certain slf4j-api version will work with any other version of slf4j-api
          // (http://www.slf4j.org/manual.html#compatibility).
          // We rely on that guarantee in frontendUi module: JGit that frontendUi depends on (via backendRoot and gitCoreJGit)
          // effectively uses whatever slf4j-api version is provided by IntelliJ.
          // SLF4j does NOT guarantee, however, that slf4j-api version X will work with any slf4j implementation version Y for X != Y.
          // To avoid a clash between JGit's slf4j-api and Intellij's slf4j implementation, we need to exclude the former.
          exclude(group: 'org.slf4j', module: 'slf4j-api')
        }
      }
    }

    junit = { ->
      dependencies {
        testImplementation group: 'junit', name: 'junit', version: junitVersion
      }
    }

    lombok = { ->
      dependencies {
        compileOnly group: 'org.projectlombok', name: 'lombok', version: lombokVersion
        annotationProcessor group: 'org.projectlombok', name: 'lombok', version: lombokVersion
      }
    }

    powerMock = { ->
      dependencies {
        testImplementation group: 'org.powermock', name: 'powermock-module-junit4', version: powerMockVersion
        testImplementation group: 'org.powermock', name: 'powermock-api-mockito2', version: powerMockVersion
      }
    }

    slf4j = { ->
      // We only need to provide an SLF4J implementation in the contexts which depend on JGit but don't depend on IntelliJ.
      // In our case, that's solely the tests of backendRoot.
      // In other contexts that require an SLF4J implementation (buildPlugin, runIde, possible but not yet present tests of frontend),
      // an SLF4J implementation is pulled in by IntelliJ.
      // Note that we don't need to agree the SLF4J implementation version here with JGit's slf4j-api version
      // since the latter is excluded (see the comment to `jgit` for more nuances).
      // The below dependency provides both slf4j-api and an implementation, both already in the same version (1.7.30 i.e. the current stable).
      dependencies {
        testImplementation group: 'org.slf4j', name: 'slf4j-simple', version: slf4jVersion
      }
    }

    vavr = { ->
      dependencies {
        implementation group: 'io.vavr', name: 'vavr', version: vavrVersion
      }
    }
  }
}
